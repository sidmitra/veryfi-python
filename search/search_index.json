{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"veryfi is a Python module for communicating with the Veryfi OCR API Installation Install from PyPi using pip , a package manager for Python. Install the package from PyPI: pip install -U veryfi You may need to run the above commands with sudo . Getting Started Obtaining Client ID and user keys If you don't have an account with Veryfi, please go ahead and register here: https://hub.veryfi.com/signup/api/ Python API Client Library The veryfi library can be used to communicate with Veryfi API. All available functionality is described here https://veryfi.github.io/veryfi-python/reference/veryfi/#client Below is the sample script using veryfi to OCR and extract data from a document: from veryfi import Client client_id = 'your_client_id' client_secret = 'your_client_secret' username = 'your_username' api_key = 'your_password' categories = [ 'Grocery' , 'Utilities' , 'Travel' ] file_path = '/tmp/invoice.jpg' # This submits document for processing (takes 3-5 seconds to get response) veryfi_client = Client ( client_id , client_secret , username , api_key ) response = veryfi_client . process_document ( file_path , categories = categories ) response # or with url response = veryfi_client . process_document_url ( url , external_id = some_id ) response >>> { \"abn_number\" : \"\" , \"account_number\" : \"\" , \"bill_to_address\" : \"130 INTERSTATE BLVD, SUIT 21 \\n NASHEVILLE, NC 28806\" , \"bill_to_name\" : \"FAST ROOFING COMPANY, LLC\" , \"card_number\" : \"\" , \"category\" : \"Hardware Supplies\" , \"currency_code\" : \"USD\" , \"date\" : \"2019-08-01 00:00:00\" , \"due_date\" : \"2019-09-01\" , \"discount\" : 0 , \"external_id\" : \"\" , \"id\" : 28933541012 , \"img_thumbnail_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da_t.jpg\" , \"img_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da.pdf\" , \"invoice_number\" : \"1234568\" , \"line_items\" : [ { \"date\" : \"\" , \"description\" : \"SFTY TAGS LCKED OUT 250BX 426NS\" , \"discount\" : 0 , \"order\" : 1 , \"price\" : 200.0 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"PTW-901444\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 200.00 , \"type\" : \"purchase\" , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"WEDGE ANCHOR. PLATED\" , \"discount\" : 0 , \"order\" : 2 , \"price\" : 3.75 , \"quantity\" : 100 , \"reference\" : \"\" , \"sku\" : \"WA-12-414\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 375.00 , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"SYP #2 KD-HT UNTREATED\" , \"discount\" : 0 , \"order\" : 9 , \"price\" : 11.49 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"WE-27517\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 11.49 , \"unit_of_measure\" : \"pc\" } ], \"ocr_text\" : \" \\n ACE \\n The helpful place. \\n Ace Hardware \\t\\t\\t\\t\\t\\t INVOICE \\n 5726.....\" , \"payment_display_name\" : \"\" , \"payment_terms\" : \"\" , \"payment_type\" : \"\" , \"purchase_order_number\" : \"\" , \"reference_number\" : \"VBAJD-32541\" , \"shipping\" : 0 , \"subtotal\" : 586.49 , \"tax\" : 41.05 , \"tax_lines\" : [{ \"name\" : \"state tax\" , \"rate\" : 7.0 , \"total\" : 41.05 }], \"tip\" : 0 , \"total\" : 627.54 , \"vat_number\" : \"\" , \"vendor\" : { \"address\" : \"5726 Memorial Blvd, Saint George, SC 29477\" , \"name\" : \"Hutto Ace Hardware\" , \"raw_name\" : \"Ace Hardware\" , \"phone_number\" : \"(843) 563-4012\" , \"vendor_logo\" : \"https://cdn.veryfi.com/logos/us/953982859.png\" , \"vendor_type\" : \"hardware stores\" }, \"vendor_vat_number\" : \"\" , \"vendor_iban\" : \"\" , \"vendor_bank_number\" : \"\" , \"vendor_bank_name\" : \"\" } Update a document new_vendor = {\"name\": \"Starbucks\", \"address\": \"123 Easy Str, San Francisco, CA 94158\"} category = \"Meals & Entertainment\" new_total = 11.23 veryfi_client.update_document(id=12345, vendor=new_vendor, category=new_category, total=new_total) Need help? If you run into any issue or need help installing or using the library, please contact support@veryfi.com. If you found a bug in this library or would like new features added, then open an issue or pull requests against this repo! To learn more about Veryfi visit https://www.veryfi.com/ Tutorial Video","title":"Home"},{"location":"#installation","text":"Install from PyPi using pip , a package manager for Python. Install the package from PyPI: pip install -U veryfi You may need to run the above commands with sudo .","title":"Installation"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#obtaining-client-id-and-user-keys","text":"If you don't have an account with Veryfi, please go ahead and register here: https://hub.veryfi.com/signup/api/","title":"Obtaining Client ID and user keys"},{"location":"#python-api-client-library","text":"The veryfi library can be used to communicate with Veryfi API. All available functionality is described here https://veryfi.github.io/veryfi-python/reference/veryfi/#client Below is the sample script using veryfi to OCR and extract data from a document: from veryfi import Client client_id = 'your_client_id' client_secret = 'your_client_secret' username = 'your_username' api_key = 'your_password' categories = [ 'Grocery' , 'Utilities' , 'Travel' ] file_path = '/tmp/invoice.jpg' # This submits document for processing (takes 3-5 seconds to get response) veryfi_client = Client ( client_id , client_secret , username , api_key ) response = veryfi_client . process_document ( file_path , categories = categories ) response # or with url response = veryfi_client . process_document_url ( url , external_id = some_id ) response >>> { \"abn_number\" : \"\" , \"account_number\" : \"\" , \"bill_to_address\" : \"130 INTERSTATE BLVD, SUIT 21 \\n NASHEVILLE, NC 28806\" , \"bill_to_name\" : \"FAST ROOFING COMPANY, LLC\" , \"card_number\" : \"\" , \"category\" : \"Hardware Supplies\" , \"currency_code\" : \"USD\" , \"date\" : \"2019-08-01 00:00:00\" , \"due_date\" : \"2019-09-01\" , \"discount\" : 0 , \"external_id\" : \"\" , \"id\" : 28933541012 , \"img_thumbnail_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da_t.jpg\" , \"img_url\" : \"https://scdn.veryfi.com/documents/5rb8d5q0-3ae0-4f55-a54b-c01a553ab2da.pdf\" , \"invoice_number\" : \"1234568\" , \"line_items\" : [ { \"date\" : \"\" , \"description\" : \"SFTY TAGS LCKED OUT 250BX 426NS\" , \"discount\" : 0 , \"order\" : 1 , \"price\" : 200.0 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"PTW-901444\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 200.00 , \"type\" : \"purchase\" , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"WEDGE ANCHOR. PLATED\" , \"discount\" : 0 , \"order\" : 2 , \"price\" : 3.75 , \"quantity\" : 100 , \"reference\" : \"\" , \"sku\" : \"WA-12-414\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 375.00 , \"unit_of_measure\" : \"pc\" }, { \"date\" : \"\" , \"description\" : \"SYP #2 KD-HT UNTREATED\" , \"discount\" : 0 , \"order\" : 9 , \"price\" : 11.49 , \"quantity\" : 1 , \"reference\" : \"\" , \"sku\" : \"WE-27517\" , \"tax\" : 0 , \"tax_rate\" : 0 , \"total\" : 11.49 , \"unit_of_measure\" : \"pc\" } ], \"ocr_text\" : \" \\n ACE \\n The helpful place. \\n Ace Hardware \\t\\t\\t\\t\\t\\t INVOICE \\n 5726.....\" , \"payment_display_name\" : \"\" , \"payment_terms\" : \"\" , \"payment_type\" : \"\" , \"purchase_order_number\" : \"\" , \"reference_number\" : \"VBAJD-32541\" , \"shipping\" : 0 , \"subtotal\" : 586.49 , \"tax\" : 41.05 , \"tax_lines\" : [{ \"name\" : \"state tax\" , \"rate\" : 7.0 , \"total\" : 41.05 }], \"tip\" : 0 , \"total\" : 627.54 , \"vat_number\" : \"\" , \"vendor\" : { \"address\" : \"5726 Memorial Blvd, Saint George, SC 29477\" , \"name\" : \"Hutto Ace Hardware\" , \"raw_name\" : \"Ace Hardware\" , \"phone_number\" : \"(843) 563-4012\" , \"vendor_logo\" : \"https://cdn.veryfi.com/logos/us/953982859.png\" , \"vendor_type\" : \"hardware stores\" }, \"vendor_vat_number\" : \"\" , \"vendor_iban\" : \"\" , \"vendor_bank_number\" : \"\" , \"vendor_bank_name\" : \"\" } Update a document new_vendor = {\"name\": \"Starbucks\", \"address\": \"123 Easy Str, San Francisco, CA 94158\"} category = \"Meals & Entertainment\" new_total = 11.23 veryfi_client.update_document(id=12345, vendor=new_vendor, category=new_category, total=new_total)","title":"Python API Client Library"},{"location":"#need-help","text":"If you run into any issue or need help installing or using the library, please contact support@veryfi.com. If you found a bug in this library or would like new features added, then open an issue or pull requests against this repo! To learn more about Veryfi visit https://www.veryfi.com/","title":"Need help?"},{"location":"#tutorial-video","text":"","title":"Tutorial Video"},{"location":"CONTRIBUTORS/","text":"Release process Release and upload to pypi is set up in github actions. For that, simply create a release here https://github.com/veryfi/veryfi-python/releases Versioning pbr manages all the package metadata: * it uses requirements.txt * it adds version To check the package build, simply run python setup.py sdist bdist_wheel","title":"Contributors"},{"location":"CONTRIBUTORS/#release-process","text":"Release and upload to pypi is set up in github actions. For that, simply create a release here https://github.com/veryfi/veryfi-python/releases","title":"Release process"},{"location":"CONTRIBUTORS/#versioning","text":"pbr manages all the package metadata: * it uses requirements.txt * it adds version To check the package build, simply run python setup.py sdist bdist_wheel","title":"Versioning"},{"location":"NEWS/","text":"CHANGES 3.1.1 Install dependencies in update-docs workflow 3.1.0 Add support for operations with line items 3.0.0 Return proper 404 and other errors 3.0.0 Use v8 by default, lower timeout 2.1.0 BREAKING - Remove process_document_file Fix docs 2.0.0 Make username and apikey required, pass kwargs Add tests Add tox-gh-actions Let tox manage python versions Feature/updates gitignore (#24) Remove MAX_FILE_SIZE_MB Update README.md 1.1.1 Unpin requests Update python-package.yml Update README.md Force push fresh autodocs to github pages 1.1.0 Add update_document Add portray autodocs Fix code 1.0.0 Clean test deps Update README.md 0.0.7 Fix publish package condition Add a note on release Fix description, remove authors generation 0.0.6 Add missing parameters to process_document_url Add boost Make it black (#4) Clean python versions Bump to 0.0.5 Remove python 3.5 support Add responses Clean setup Add test Fix file_url parameter, add Accept header Better message in exceptions","title":"News"},{"location":"NEWS/#changes","text":"","title":"CHANGES"},{"location":"NEWS/#311","text":"Install dependencies in update-docs workflow","title":"3.1.1"},{"location":"NEWS/#310","text":"Add support for operations with line items","title":"3.1.0"},{"location":"NEWS/#300","text":"Return proper 404 and other errors","title":"3.0.0"},{"location":"NEWS/#300_1","text":"Use v8 by default, lower timeout","title":"3.0.0"},{"location":"NEWS/#210","text":"BREAKING - Remove process_document_file Fix docs","title":"2.1.0"},{"location":"NEWS/#200","text":"Make username and apikey required, pass kwargs Add tests Add tox-gh-actions Let tox manage python versions Feature/updates gitignore (#24) Remove MAX_FILE_SIZE_MB Update README.md","title":"2.0.0"},{"location":"NEWS/#111","text":"Unpin requests Update python-package.yml Update README.md Force push fresh autodocs to github pages","title":"1.1.1"},{"location":"NEWS/#110","text":"Add update_document Add portray autodocs Fix code","title":"1.1.0"},{"location":"NEWS/#100","text":"Clean test deps Update README.md","title":"1.0.0"},{"location":"NEWS/#007","text":"Fix publish package condition Add a note on release Fix description, remove authors generation","title":"0.0.7"},{"location":"NEWS/#006","text":"Add missing parameters to process_document_url Add boost Make it black (#4) Clean python versions Bump to 0.0.5 Remove python 3.5 support Add responses Clean setup Add test Fix file_url parameter, add Accept header Better message in exceptions","title":"0.0.6"},{"location":"reference/veryfi/","text":"Module veryfi None None View Source from veryfi.client import * Sub-modules veryfi.client veryfi.errors veryfi.model Variables TYPE_CHECKING","title":"Index"},{"location":"reference/veryfi/#module-veryfi","text":"None None View Source from veryfi.client import *","title":"Module veryfi"},{"location":"reference/veryfi/#sub-modules","text":"veryfi.client veryfi.errors veryfi.model","title":"Sub-modules"},{"location":"reference/veryfi/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/veryfi/client/","text":"Module veryfi.client None None View Source import base64 import hashlib import hmac import json import os import time from typing import * import requests from veryfi.model import AddLineItem , UpdateLineItem from veryfi.errors import VeryfiClientError class Client : API_VERSION = \"v8\" API_TIMEOUT = 30 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\" , \"Automotive\" , \"Bank Charges & Fees\" , \"Legal & Professional Services\" , \"Insurance\" , \"Meals & Entertainment\" , \"Office Supplies & Software\" , \"Taxes & Licenses\" , \"Travel\" , \"Rent & Lease\" , \"Repairs & Maintenance\" , \"Payroll\" , \"Utilities\" , \"Job Supplies\" , \"Grocery\" , ] def __init__ ( self , client_id , client_secret , username , api_key , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ): self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . api_version = api_version self . versioned_url = self . base_url + self . api_version self . timeout = timeout self . headers = {} self . _session = requests . Session () def _get_headers ( self ) -> Dict : \"\"\" Prepares the headers needed for a request. :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/3.0.0\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } final_headers . update ({ \"Authorization\" : f \"apikey { self . username } : { self . api_key } \" }) return final_headers def _request ( self , http_verb , endpoint_name , request_arguments ): \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" headers = self . _get_headers () api_url = \" {0} /partner {1} \" . format ( self . versioned_url , endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200 , 201 , 202 , 204 ]: raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ): \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp: {} \" . format ( timestamp ) for key in payload_params . keys (): value = payload_params [ key ] payload = \" {0} , {1} : {2} \" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ) . digest () base64_signature = base64 . b64encode ( tmp_signature ) . decode ( \"utf-8\" ) . strip () return base64_signature def get_documents ( self ): \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ): \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/ {} /\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path : str , categories : Optional [ List ] = None , delete_after_processing : bool = False , ** kwargs : Dict , ): \"\"\" Process a document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param kwargs: Additional request parameters :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List [ str ]] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List [ str ]] = None , ** kwargs : Dict , ) -> Dict : \"\"\"Process Document from url and extract all the fields from it. :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document_url ( self , file_url : str , file_name : Optional [ str ] = None , ** kwargs : Dict ) -> Dict : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_url: Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" if file_name is None : file_name = os . path . basename ( file_url ) endpoint_name = \"/w9s/\" request_arguments = { \"file_name\" : file_name , \"file_url\" : file_url , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document ( self , file_path : str , file_name : Optional [ str ] = None , ** kwargs ): \"\"\" Process W9 Document from url and extract all the fields from it. :param file_path: Path on disk to a file to submit for data extraction :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/w9s/\" if file_name is None : file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def delete_document ( self , document_id ): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/ { document_id } /\" request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , document_id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\")``` :param document_id: ID of the document you'd like to update :param kwargs: fields to update :return: A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/ { document_id } /\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) def get_line_items ( self , document_id ): \"\"\" Retrieve all line items for a document. :param document_id: ID of the document you'd like to retrieve :return: List of line items extracted from the document \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/\" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def get_line_item ( self , document_id , line_item_id ): \"\"\" Retrieve a line item for existing document by ID. :param document_id: ID of the document you'd like to retrieve :param line_item_id: ID of the line item you'd like to retrieve :return: Line item extracted from the document \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/ { line_item_id } \" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def add_line_item ( self , document_id : int , payload : Dict ) -> Dict : \"\"\" Add a new line item on an existing document. :param document_id: ID of the document you'd like to update :param payload: line item object to add :return: Added line item data \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/\" request_arguments = AddLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict : \"\"\" Update an existing line item on an existing document. :param document_id: ID of the document you'd like to update :param line_item_id: ID of the line item you'd like to update :param payload: line item object to update :return: Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/ { line_item_id } \" request_arguments = UpdateLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"PUT\" , endpoint_name , request_arguments ) def delete_line_items ( self , document_id ): \"\"\" Delete all line items on an existing document. :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/\" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def delete_line_item ( self , document_id , line_item_id ): \"\"\" Delete an existing line item on an existing document. :param document_id: ID of the document you'd like to delete :param line_item_id: ID of the line item you'd like to delete \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/ { line_item_id } \" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments ) Variables TYPE_CHECKING Classes Client class Client ( client_id , client_secret , username , api_key , base_url = 'https://api.veryfi.com/api/' , api_version = 'v8' , timeout = 30 ) View Source class Client : API_VERSION = \"v8\" API_TIMEOUT = 30 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\", \"Automotive\", \"Bank Charges & Fees\", \"Legal & Professional Services\", \"Insurance\", \"Meals & Entertainment\", \"Office Supplies & Software\", \"Taxes & Licenses\", \"Travel\", \"Rent & Lease\", \"Repairs & Maintenance\", \"Payroll\", \"Utilities\", \"Job Supplies\", \"Grocery\", ] def __init__ ( self , client_id , client_secret , username , api_key , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ) : self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . api_version = api_version self . versioned_url = self . base_url + self . api_version self . timeout = timeout self . headers = {} self . _session = requests . Session () def _get_headers ( self ) -> Dict : \"\"\" Prepares the headers needed for a request. :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/3.0.0\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } final_headers . update ( { \"Authorization\" : f \"apikey {self.username}:{self.api_key}\" } ) return final_headers def _request ( self , http_verb , endpoint_name , request_arguments ) : \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" headers = self . _get_headers () api_url = \"{0}/partner{1}\" . format ( self . versioned_url , endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200, 201, 202, 204 ] : raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ) : \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp:{}\" . format ( timestamp ) for key in payload_params . keys () : value = payload_params [ key ] payload = \"{0},{1}:{2}\" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ). digest () base64_signature = base64 . b64encode ( tmp_signature ). decode ( \"utf-8\" ). strip () return base64_signature def get_documents ( self ) : \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ) : \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/{}/\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path : str , categories : Optional [ List ] = None , delete_after_processing : bool = False , ** kwargs : Dict , ) : \"\"\" Process a document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param kwargs: Additional request parameters :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ** kwargs : Dict , ) -> Dict : \"\"\"Process Document from url and extract all the fields from it. :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document_url ( self , file_url : str , file_name : Optional [ str ] = None , ** kwargs : Dict ) -> Dict : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_url: Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" if file_name is None : file_name = os . path . basename ( file_url ) endpoint_name = \"/w9s/\" request_arguments = { \"file_name\" : file_name , \"file_url\" : file_url , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document ( self , file_path : str , file_name : Optional [ str ] = None , ** kwargs ) : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_path: Path on disk to a file to submit for data extraction :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/w9s/\" if file_name is None : file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def delete_document ( self , document_id ) : \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/{document_id}/\" request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , document_id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param document_id: ID of the document you'd like to update :param kwargs: fields to update :return: A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/{document_id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) def get_line_items ( self , document_id ) : \"\"\" Retrieve all line items for a document. :param document_id: ID of the document you'd like to retrieve :return: List of line items extracted from the document \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def get_line_item ( self , document_id , line_item_id ) : \"\"\" Retrieve a line item for existing document by ID. :param document_id: ID of the document you'd like to retrieve :param line_item_id: ID of the line item you'd like to retrieve :return: Line item extracted from the document \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def add_line_item ( self , document_id : int , payload : Dict ) -> Dict : \"\"\" Add a new line item on an existing document. :param document_id: ID of the document you'd like to update :param payload: line item object to add :return: Added line item data \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = AddLineItem ( ** payload ). dict ( exclude_none = True ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict : \"\"\" Update an existing line item on an existing document. :param document_id: ID of the document you'd like to update :param line_item_id: ID of the line item you'd like to update :param payload: line item object to update :return: Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = UpdateLineItem ( ** payload ). dict ( exclude_none = True ) return self . _request ( \"PUT\" , endpoint_name , request_arguments ) def delete_line_items ( self , document_id ) : \"\"\" Delete all line items on an existing document. :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def delete_line_item ( self , document_id , line_item_id ) : \"\"\" Delete an existing line item on an existing document. :param document_id: ID of the document you'd like to delete :param line_item_id: ID of the line item you'd like to delete \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments ) Class variables API_TIMEOUT API_VERSION BASE_URL CATEGORIES Methods add_line_item def add_line_item ( self , document_id : int , payload : Dict ) -> Dict Add a new line item on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to update None payload None line item object to add None Returns: Type Description None Added line item data View Source def add_line_item ( self , document_id : int , payload : Dict ) -> Dict : \"\"\" Add a new line item on an existing document. :param document_id: ID of the document you'd like to update :param payload: line item object to add :return: Added line item data \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = AddLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) delete_document def delete_document ( self , document_id ) Delete Document from Veryfi Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None View Source def delete_document(self, document_id): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f\"/documents/{document_id}/\" request_arguments = {\"id\": document_id} self._request(\"DELETE\", endpoint_name, request_arguments) delete_line_item def delete_line_item ( self , document_id , line_item_id ) Delete an existing line item on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None line_item_id None ID of the line item you'd like to delete None View Source def delete_line_item(self, document_id, line_item_id): \"\"\" Delete an existing line item on an existing document. :param document_id: ID of the document you'd like to delete :param line_item_id: ID of the line item you'd like to delete \"\"\" endpoint_name = f\"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = {} self._request(\"DELETE\", endpoint_name, request_arguments) delete_line_items def delete_line_items ( self , document_id ) Delete all line items on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None View Source def delete_line_items(self, document_id): \"\"\" Delete all line items on an existing document. :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f\"/documents/{document_id}/line-items/\" request_arguments = {} self._request(\"DELETE\", endpoint_name, request_arguments) get_document def get_document ( self , document_id ) Retrieve document by ID Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None Returns: Type Description None Data extracted from the Document View Source def get_document ( self , document_id ) : \"\"\" Retrieve document by ID : param document_id : ID of the document you ' d like to retrieve :return : Data extracted from the Document \"\"\" endpoint_name = \" /documents/{}/ \" . format ( document_id ) request_arguments = { \" id \" : document_id } document = self . _request ( \" GET \" , endpoint_name , request_arguments ) return document get_documents def get_documents ( self ) Get list of documents Returns: Type Description None List of previously processed documents View Source def get_documents ( self ) : \"\"\" Get list of documents : return : List of previously processed documents \"\"\" endpoint_name = \" /documents/ \" request_arguments = {} documents = self . _request ( \" GET \" , endpoint_name , request_arguments ) if \" documents \" in documents : return documents [ \" documents \" ] return documents get_line_item def get_line_item ( self , document_id , line_item_id ) Retrieve a line item for existing document by ID. Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None line_item_id None ID of the line item you'd like to retrieve None Returns: Type Description None Line item extracted from the document View Source def get_line_item ( self , document_id , line_item_id ) : \"\"\" Retrieve a line item for existing document by ID . : param document_id : ID of the document you ' d like to retrieve :param line_item_id : ID of the line item you ' d like to retrieve :return : Line item extracted from the document \"\"\" endpoint_name = f \" /documents/{document_id}/line-items/{line_item_id} \" request_arguments = {} line_items = self . _request ( \" GET \" , endpoint_name , request_arguments ) return line_items get_line_items def get_line_items ( self , document_id ) Retrieve all line items for a document. Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None Returns: Type Description None List of line items extracted from the document View Source def get_line_items ( self , document_id ) : \"\"\" Retrieve all line items for a document . : param document_id : ID of the document you ' d like to retrieve :return : List of line items extracted from the document \"\"\" endpoint_name = f \" /documents/{document_id}/line-items/ \" request_arguments = {} line_items = self . _request ( \" GET \" , endpoint_name , request_arguments ) return line_items process_document def process_document ( self , file_path : str , categories : Union [ List , NoneType ] = None , delete_after_processing : bool = False , ** kwargs : Dict ) Process a document and extract all the fields from it Parameters: Name Type Description Default file_path None Path on disk to a file to submit for data extraction None categories None List of categories Veryfi can use to categorize the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document View Source def process_document ( self , file_path : str , categories : Optional [ List ] = None , delete_after_processing : bool = False , ** kwargs : Dict , ) : \"\"\" Process a document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param kwargs: Additional request parameters :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document process_document_url def process_document_url ( self , file_url : Union [ str , NoneType ] = None , categories : Union [ List [ str ], NoneType ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Union [ str , NoneType ] = None , max_pages_to_process : Union [ int , NoneType ] = None , file_urls : Union [ List [ str ], NoneType ] = None , ** kwargs : Dict ) -> Dict Process Document from url and extract all the fields from it. Parameters: Name Type Description Default file_url None Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". None file_urls None Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] None categories None List of categories to use when categorizing the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None max_pages_to_process None When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. None boost_mode None Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 None external_id None Optional custom document identifier. Use this if you would like to assign your own ID to documents None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document. View Source def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ** kwargs : Dict , ) -> Dict : \"\"\"Process Document from url and extract all the fields from it. :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) process_w9_document def process_w9_document ( self , file_path : str , file_name : Union [ str , NoneType ] = None , ** kwargs ) Process W9 Document from url and extract all the fields from it. Parameters: Name Type Description Default file_path None Path on disk to a file to submit for data extraction None file_name None Optional name of file, eg. receipt.jpg None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document. View Source def process_w9_document ( self , file_path : str , file_name : Optional [ str ] = None , ** kwargs ) : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_path: Path on disk to a file to submit for data extraction :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/w9s/\" if file_name is None : file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document process_w9_document_url def process_w9_document_url ( self , file_url : str , file_name : Union [ str , NoneType ] = None , ** kwargs : Dict ) -> Dict Process W9 Document from url and extract all the fields from it. Parameters: Name Type Description Default file_url None Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". None file_name None Optional name of file, eg. receipt.jpg None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document. View Source def process_w9_document_url ( self , file_url : str , file_name : Optional [ str ] = None , ** kwargs : Dict ) -> Dict : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_url: Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" if file_name is None : file_name = os . path . basename ( file_url ) endpoint_name = \"/w9s/\" request_arguments = { \"file_name\" : file_name , \"file_url\" : file_url , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) update_document def update_document ( self , document_id : int , ** kwargs ) -> Dict Update data for a previously processed document, including almost any field like vendor , date , notes and etc. veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\") Parameters: Name Type Description Default document_id None ID of the document you'd like to update None kwargs None fields to update None Returns: Type Description None A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. View Source def update_document ( self , document_id : int , ** kwargs ) -> Dict : \" \"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param document_id: ID of the document you'd like to update :param kwargs: fields to update :return: A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. \"\" \" endpoint_name = f \"/documents/{document_id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) update_line_item def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict Update an existing line item on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to update None line_item_id None ID of the line item you'd like to update None payload None line item object to update None Returns: Type Description None Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. View Source def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict : \"\"\" Update an existing line item on an existing document. :param document_id: ID of the document you'd like to update :param line_item_id: ID of the line item you'd like to update :param payload: line item object to update :return: Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = UpdateLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"PUT\" , endpoint_name , request_arguments )","title":"Client"},{"location":"reference/veryfi/client/#module-veryficlient","text":"None None View Source import base64 import hashlib import hmac import json import os import time from typing import * import requests from veryfi.model import AddLineItem , UpdateLineItem from veryfi.errors import VeryfiClientError class Client : API_VERSION = \"v8\" API_TIMEOUT = 30 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\" , \"Automotive\" , \"Bank Charges & Fees\" , \"Legal & Professional Services\" , \"Insurance\" , \"Meals & Entertainment\" , \"Office Supplies & Software\" , \"Taxes & Licenses\" , \"Travel\" , \"Rent & Lease\" , \"Repairs & Maintenance\" , \"Payroll\" , \"Utilities\" , \"Job Supplies\" , \"Grocery\" , ] def __init__ ( self , client_id , client_secret , username , api_key , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ): self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . api_version = api_version self . versioned_url = self . base_url + self . api_version self . timeout = timeout self . headers = {} self . _session = requests . Session () def _get_headers ( self ) -> Dict : \"\"\" Prepares the headers needed for a request. :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/3.0.0\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } final_headers . update ({ \"Authorization\" : f \"apikey { self . username } : { self . api_key } \" }) return final_headers def _request ( self , http_verb , endpoint_name , request_arguments ): \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" headers = self . _get_headers () api_url = \" {0} /partner {1} \" . format ( self . versioned_url , endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200 , 201 , 202 , 204 ]: raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ): \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp: {} \" . format ( timestamp ) for key in payload_params . keys (): value = payload_params [ key ] payload = \" {0} , {1} : {2} \" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ) . digest () base64_signature = base64 . b64encode ( tmp_signature ) . decode ( \"utf-8\" ) . strip () return base64_signature def get_documents ( self ): \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ): \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/ {} /\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path : str , categories : Optional [ List ] = None , delete_after_processing : bool = False , ** kwargs : Dict , ): \"\"\" Process a document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param kwargs: Additional request parameters :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List [ str ]] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List [ str ]] = None , ** kwargs : Dict , ) -> Dict : \"\"\"Process Document from url and extract all the fields from it. :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document_url ( self , file_url : str , file_name : Optional [ str ] = None , ** kwargs : Dict ) -> Dict : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_url: Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" if file_name is None : file_name = os . path . basename ( file_url ) endpoint_name = \"/w9s/\" request_arguments = { \"file_name\" : file_name , \"file_url\" : file_url , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document ( self , file_path : str , file_name : Optional [ str ] = None , ** kwargs ): \"\"\" Process W9 Document from url and extract all the fields from it. :param file_path: Path on disk to a file to submit for data extraction :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/w9s/\" if file_name is None : file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()) . decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def delete_document ( self , document_id ): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/ { document_id } /\" request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , document_id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\")``` :param document_id: ID of the document you'd like to update :param kwargs: fields to update :return: A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/ { document_id } /\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) def get_line_items ( self , document_id ): \"\"\" Retrieve all line items for a document. :param document_id: ID of the document you'd like to retrieve :return: List of line items extracted from the document \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/\" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def get_line_item ( self , document_id , line_item_id ): \"\"\" Retrieve a line item for existing document by ID. :param document_id: ID of the document you'd like to retrieve :param line_item_id: ID of the line item you'd like to retrieve :return: Line item extracted from the document \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/ { line_item_id } \" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def add_line_item ( self , document_id : int , payload : Dict ) -> Dict : \"\"\" Add a new line item on an existing document. :param document_id: ID of the document you'd like to update :param payload: line item object to add :return: Added line item data \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/\" request_arguments = AddLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict : \"\"\" Update an existing line item on an existing document. :param document_id: ID of the document you'd like to update :param line_item_id: ID of the line item you'd like to update :param payload: line item object to update :return: Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/ { line_item_id } \" request_arguments = UpdateLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"PUT\" , endpoint_name , request_arguments ) def delete_line_items ( self , document_id ): \"\"\" Delete all line items on an existing document. :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/\" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def delete_line_item ( self , document_id , line_item_id ): \"\"\" Delete an existing line item on an existing document. :param document_id: ID of the document you'd like to delete :param line_item_id: ID of the line item you'd like to delete \"\"\" endpoint_name = f \"/documents/ { document_id } /line-items/ { line_item_id } \" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments )","title":"Module veryfi.client"},{"location":"reference/veryfi/client/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/veryfi/client/#classes","text":"","title":"Classes"},{"location":"reference/veryfi/client/#client","text":"class Client ( client_id , client_secret , username , api_key , base_url = 'https://api.veryfi.com/api/' , api_version = 'v8' , timeout = 30 ) View Source class Client : API_VERSION = \"v8\" API_TIMEOUT = 30 BASE_URL = \"https://api.veryfi.com/api/\" CATEGORIES = [ \"Advertising & Marketing\", \"Automotive\", \"Bank Charges & Fees\", \"Legal & Professional Services\", \"Insurance\", \"Meals & Entertainment\", \"Office Supplies & Software\", \"Taxes & Licenses\", \"Travel\", \"Rent & Lease\", \"Repairs & Maintenance\", \"Payroll\", \"Utilities\", \"Job Supplies\", \"Grocery\", ] def __init__ ( self , client_id , client_secret , username , api_key , base_url = BASE_URL , api_version = API_VERSION , timeout = API_TIMEOUT , ) : self . client_id = client_id self . client_secret = client_secret self . username = username self . api_key = api_key self . base_url = base_url self . api_version = api_version self . versioned_url = self . base_url + self . api_version self . timeout = timeout self . headers = {} self . _session = requests . Session () def _get_headers ( self ) -> Dict : \"\"\" Prepares the headers needed for a request. :return: Dictionary with headers \"\"\" final_headers = { \"User-Agent\" : \"Python Veryfi-Python/3.0.0\" , \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" , \"Client-Id\" : self . client_id , } final_headers . update ( { \"Authorization\" : f \"apikey {self.username}:{self.api_key}\" } ) return final_headers def _request ( self , http_verb , endpoint_name , request_arguments ) : \"\"\" Submit the HTTP request. :param http_verb: HTTP Method :param endpoint_name: Endpoint name such as 'documents', 'users', etc. :param request_arguments: JSON payload to send to Veryfi :return: A JSON of the response data. \"\"\" headers = self . _get_headers () api_url = \"{0}/partner{1}\" . format ( self . versioned_url , endpoint_name ) if self . client_secret : timestamp = int ( time . time () * 1000 ) signature = self . _generate_signature ( request_arguments , timestamp = timestamp ) headers . update ( { \"X-Veryfi-Request-Timestamp\" : str ( timestamp ), \"X-Veryfi-Request-Signature\" : signature , } ) response = self . _session . request ( http_verb , url = api_url , headers = headers , data = json . dumps ( request_arguments ), timeout = self . timeout , ) if response . status_code not in [ 200, 201, 202, 204 ] : raise VeryfiClientError . from_response ( response ) return response . json () def _generate_signature ( self , payload_params , timestamp ) : \"\"\" Generate unique signature for payload params. :param payload_params: JSON params to be sent to API request :param timestamp: Unix Long timestamp :return: Unique signature generated using the client_secret and the payload \"\"\" payload = \"timestamp:{}\" . format ( timestamp ) for key in payload_params . keys () : value = payload_params [ key ] payload = \"{0},{1}:{2}\" . format ( payload , key , value ) secret_bytes = bytes ( self . client_secret , \"utf-8\" ) payload_bytes = bytes ( payload , \"utf-8\" ) tmp_signature = hmac . new ( secret_bytes , msg = payload_bytes , digestmod = hashlib . sha256 ). digest () base64_signature = base64 . b64encode ( tmp_signature ). decode ( \"utf-8\" ). strip () return base64_signature def get_documents ( self ) : \"\"\" Get list of documents :return: List of previously processed documents \"\"\" endpoint_name = \"/documents/\" request_arguments = {} documents = self . _request ( \"GET\" , endpoint_name , request_arguments ) if \"documents\" in documents : return documents [ \"documents\" ] return documents def get_document ( self , document_id ) : \"\"\" Retrieve document by ID :param document_id: ID of the document you'd like to retrieve :return: Data extracted from the Document \"\"\" endpoint_name = \"/documents/{}/\" . format ( document_id ) request_arguments = { \"id\" : document_id } document = self . _request ( \"GET\" , endpoint_name , request_arguments ) return document def process_document ( self , file_path : str , categories : Optional [ List ] = None , delete_after_processing : bool = False , ** kwargs : Dict , ) : \"\"\" Process a document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param kwargs: Additional request parameters :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ** kwargs : Dict , ) -> Dict : \"\"\"Process Document from url and extract all the fields from it. :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document_url ( self , file_url : str , file_name : Optional [ str ] = None , ** kwargs : Dict ) -> Dict : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_url: Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" if file_name is None : file_name = os . path . basename ( file_url ) endpoint_name = \"/w9s/\" request_arguments = { \"file_name\" : file_name , \"file_url\" : file_url , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def process_w9_document ( self , file_path : str , file_name : Optional [ str ] = None , ** kwargs ) : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_path: Path on disk to a file to submit for data extraction :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/w9s/\" if file_name is None : file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document def delete_document ( self , document_id ) : \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/{document_id}/\" request_arguments = { \"id\" : document_id } self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def update_document ( self , document_id : int , ** kwargs ) -> Dict : \"\"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param document_id: ID of the document you'd like to update :param kwargs: fields to update :return: A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. \"\"\" endpoint_name = f \"/documents/{document_id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs ) def get_line_items ( self , document_id ) : \"\"\" Retrieve all line items for a document. :param document_id: ID of the document you'd like to retrieve :return: List of line items extracted from the document \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def get_line_item ( self , document_id , line_item_id ) : \"\"\" Retrieve a line item for existing document by ID. :param document_id: ID of the document you'd like to retrieve :param line_item_id: ID of the line item you'd like to retrieve :return: Line item extracted from the document \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = {} line_items = self . _request ( \"GET\" , endpoint_name , request_arguments ) return line_items def add_line_item ( self , document_id : int , payload : Dict ) -> Dict : \"\"\" Add a new line item on an existing document. :param document_id: ID of the document you'd like to update :param payload: line item object to add :return: Added line item data \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = AddLineItem ( ** payload ). dict ( exclude_none = True ) return self . _request ( \"POST\" , endpoint_name , request_arguments ) def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict : \"\"\" Update an existing line item on an existing document. :param document_id: ID of the document you'd like to update :param line_item_id: ID of the line item you'd like to update :param payload: line item object to update :return: Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = UpdateLineItem ( ** payload ). dict ( exclude_none = True ) return self . _request ( \"PUT\" , endpoint_name , request_arguments ) def delete_line_items ( self , document_id ) : \"\"\" Delete all line items on an existing document. :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments ) def delete_line_item ( self , document_id , line_item_id ) : \"\"\" Delete an existing line item on an existing document. :param document_id: ID of the document you'd like to delete :param line_item_id: ID of the line item you'd like to delete \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = {} self . _request ( \"DELETE\" , endpoint_name , request_arguments )","title":"Client"},{"location":"reference/veryfi/client/#class-variables","text":"API_TIMEOUT API_VERSION BASE_URL CATEGORIES","title":"Class variables"},{"location":"reference/veryfi/client/#methods","text":"","title":"Methods"},{"location":"reference/veryfi/client/#add_line_item","text":"def add_line_item ( self , document_id : int , payload : Dict ) -> Dict Add a new line item on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to update None payload None line item object to add None Returns: Type Description None Added line item data View Source def add_line_item ( self , document_id : int , payload : Dict ) -> Dict : \"\"\" Add a new line item on an existing document. :param document_id: ID of the document you'd like to update :param payload: line item object to add :return: Added line item data \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/\" request_arguments = AddLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"POST\" , endpoint_name , request_arguments )","title":"add_line_item"},{"location":"reference/veryfi/client/#delete_document","text":"def delete_document ( self , document_id ) Delete Document from Veryfi Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None View Source def delete_document(self, document_id): \"\"\" Delete Document from Veryfi :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f\"/documents/{document_id}/\" request_arguments = {\"id\": document_id} self._request(\"DELETE\", endpoint_name, request_arguments)","title":"delete_document"},{"location":"reference/veryfi/client/#delete_line_item","text":"def delete_line_item ( self , document_id , line_item_id ) Delete an existing line item on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None line_item_id None ID of the line item you'd like to delete None View Source def delete_line_item(self, document_id, line_item_id): \"\"\" Delete an existing line item on an existing document. :param document_id: ID of the document you'd like to delete :param line_item_id: ID of the line item you'd like to delete \"\"\" endpoint_name = f\"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = {} self._request(\"DELETE\", endpoint_name, request_arguments)","title":"delete_line_item"},{"location":"reference/veryfi/client/#delete_line_items","text":"def delete_line_items ( self , document_id ) Delete all line items on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to delete None View Source def delete_line_items(self, document_id): \"\"\" Delete all line items on an existing document. :param document_id: ID of the document you'd like to delete \"\"\" endpoint_name = f\"/documents/{document_id}/line-items/\" request_arguments = {} self._request(\"DELETE\", endpoint_name, request_arguments)","title":"delete_line_items"},{"location":"reference/veryfi/client/#get_document","text":"def get_document ( self , document_id ) Retrieve document by ID Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None Returns: Type Description None Data extracted from the Document View Source def get_document ( self , document_id ) : \"\"\" Retrieve document by ID : param document_id : ID of the document you ' d like to retrieve :return : Data extracted from the Document \"\"\" endpoint_name = \" /documents/{}/ \" . format ( document_id ) request_arguments = { \" id \" : document_id } document = self . _request ( \" GET \" , endpoint_name , request_arguments ) return document","title":"get_document"},{"location":"reference/veryfi/client/#get_documents","text":"def get_documents ( self ) Get list of documents Returns: Type Description None List of previously processed documents View Source def get_documents ( self ) : \"\"\" Get list of documents : return : List of previously processed documents \"\"\" endpoint_name = \" /documents/ \" request_arguments = {} documents = self . _request ( \" GET \" , endpoint_name , request_arguments ) if \" documents \" in documents : return documents [ \" documents \" ] return documents","title":"get_documents"},{"location":"reference/veryfi/client/#get_line_item","text":"def get_line_item ( self , document_id , line_item_id ) Retrieve a line item for existing document by ID. Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None line_item_id None ID of the line item you'd like to retrieve None Returns: Type Description None Line item extracted from the document View Source def get_line_item ( self , document_id , line_item_id ) : \"\"\" Retrieve a line item for existing document by ID . : param document_id : ID of the document you ' d like to retrieve :param line_item_id : ID of the line item you ' d like to retrieve :return : Line item extracted from the document \"\"\" endpoint_name = f \" /documents/{document_id}/line-items/{line_item_id} \" request_arguments = {} line_items = self . _request ( \" GET \" , endpoint_name , request_arguments ) return line_items","title":"get_line_item"},{"location":"reference/veryfi/client/#get_line_items","text":"def get_line_items ( self , document_id ) Retrieve all line items for a document. Parameters: Name Type Description Default document_id None ID of the document you'd like to retrieve None Returns: Type Description None List of line items extracted from the document View Source def get_line_items ( self , document_id ) : \"\"\" Retrieve all line items for a document . : param document_id : ID of the document you ' d like to retrieve :return : List of line items extracted from the document \"\"\" endpoint_name = f \" /documents/{document_id}/line-items/ \" request_arguments = {} line_items = self . _request ( \" GET \" , endpoint_name , request_arguments ) return line_items","title":"get_line_items"},{"location":"reference/veryfi/client/#process_document","text":"def process_document ( self , file_path : str , categories : Union [ List , NoneType ] = None , delete_after_processing : bool = False , ** kwargs : Dict ) Process a document and extract all the fields from it Parameters: Name Type Description Default file_path None Path on disk to a file to submit for data extraction None categories None List of categories Veryfi can use to categorize the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document View Source def process_document ( self , file_path : str , categories : Optional [ List ] = None , delete_after_processing : bool = False , ** kwargs : Dict , ) : \"\"\" Process a document and extract all the fields from it :param file_path: Path on disk to a file to submit for data extraction :param categories: List of categories Veryfi can use to categorize the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param kwargs: Additional request parameters :return: Data extracted from the document \"\"\" endpoint_name = \"/documents/\" if not categories : categories = self . CATEGORIES file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , \"categories\" : categories , \"auto_delete\" : delete_after_processing , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document","title":"process_document"},{"location":"reference/veryfi/client/#process_document_url","text":"def process_document_url ( self , file_url : Union [ str , NoneType ] = None , categories : Union [ List [ str ], NoneType ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Union [ str , NoneType ] = None , max_pages_to_process : Union [ int , NoneType ] = None , file_urls : Union [ List [ str ], NoneType ] = None , ** kwargs : Dict ) -> Dict Process Document from url and extract all the fields from it. Parameters: Name Type Description Default file_url None Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". None file_urls None Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\"https://cdn.example.com/receipt1.jpg\", \"https://cdn.example.com/receipt2.jpg\"] None categories None List of categories to use when categorizing the document None delete_after_processing None Delete this document from Veryfi after data has been extracted None max_pages_to_process None When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. None boost_mode None Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 None external_id None Optional custom document identifier. Use this if you would like to assign your own ID to documents None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document. View Source def process_document_url ( self , file_url : Optional [ str ] = None , categories : Optional [ List[str ] ] = None , delete_after_processing = False , boost_mode : int = 0 , external_id : Optional [ str ] = None , max_pages_to_process : Optional [ int ] = None , file_urls : Optional [ List[str ] ] = None , ** kwargs : Dict , ) -> Dict : \"\"\"Process Document from url and extract all the fields from it. :param file_url: Required if file_urls isn't specified. Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_urls: Required if file_url isn't specifies. List of publicly accessible URLs to multiple files, e.g. [\" https : // cdn . example . com / receipt1 . jpg \", \" https : // cdn . example . com / receipt2 . jpg \"] :param categories: List of categories to use when categorizing the document :param delete_after_processing: Delete this document from Veryfi after data has been extracted :param max_pages_to_process: When sending a long document to Veryfi for processing, this parameter controls how many pages of the document will be read and processed, starting from page 1. :param boost_mode: Flag that tells Veryfi whether boost mode should be enabled. When set to 1, Veryfi will skip data enrichment steps, but will process the document faster. Default value for this flag is 0 :param external_id: Optional custom document identifier. Use this if you would like to assign your own ID to documents :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/documents/\" request_arguments = { \"auto_delete\" : delete_after_processing , \"boost_mode\" : boost_mode , \"categories\" : categories , \"external_id\" : external_id , \"file_url\" : file_url , \"file_urls\" : file_urls , \"max_pages_to_process\" : max_pages_to_process , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments )","title":"process_document_url"},{"location":"reference/veryfi/client/#process_w9_document","text":"def process_w9_document ( self , file_path : str , file_name : Union [ str , NoneType ] = None , ** kwargs ) Process W9 Document from url and extract all the fields from it. Parameters: Name Type Description Default file_path None Path on disk to a file to submit for data extraction None file_name None Optional name of file, eg. receipt.jpg None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document. View Source def process_w9_document ( self , file_path : str , file_name : Optional [ str ] = None , ** kwargs ) : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_path: Path on disk to a file to submit for data extraction :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" endpoint_name = \"/w9s/\" if file_name is None : file_name = os . path . basename ( file_path ) with open ( file_path , \"rb\" ) as image_file : base64_encoded_string = base64 . b64encode ( image_file . read ()). decode ( \"utf-8\" ) request_arguments = { \"file_name\" : file_name , \"file_data\" : base64_encoded_string , } request_arguments . update ( kwargs ) document = self . _request ( \"POST\" , endpoint_name , request_arguments ) return document","title":"process_w9_document"},{"location":"reference/veryfi/client/#process_w9_document_url","text":"def process_w9_document_url ( self , file_url : str , file_name : Union [ str , NoneType ] = None , ** kwargs : Dict ) -> Dict Process W9 Document from url and extract all the fields from it. Parameters: Name Type Description Default file_url None Publicly accessible URL to a file, e.g. \"https://cdn.example.com/receipt.jpg\". None file_name None Optional name of file, eg. receipt.jpg None kwargs None Additional request parameters None Returns: Type Description None Data extracted from the document. View Source def process_w9_document_url ( self , file_url : str , file_name : Optional [ str ] = None , ** kwargs : Dict ) -> Dict : \"\"\" Process W9 Document from url and extract all the fields from it. :param file_url: Publicly accessible URL to a file, e.g. \" https : // cdn . example . com / receipt . jpg \". :param file_name: Optional name of file, eg. receipt.jpg :param kwargs: Additional request parameters :return: Data extracted from the document. \"\"\" if file_name is None : file_name = os . path . basename ( file_url ) endpoint_name = \"/w9s/\" request_arguments = { \"file_name\" : file_name , \"file_url\" : file_url , } request_arguments . update ( kwargs ) return self . _request ( \"POST\" , endpoint_name , request_arguments )","title":"process_w9_document_url"},{"location":"reference/veryfi/client/#update_document","text":"def update_document ( self , document_id : int , ** kwargs ) -> Dict Update data for a previously processed document, including almost any field like vendor , date , notes and etc. veryfi_client.update_document(id, date=\"2021-01-01\", notes=\"look what I did\") Parameters: Name Type Description Default document_id None ID of the document you'd like to update None kwargs None fields to update None Returns: Type Description None A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. View Source def update_document ( self , document_id : int , ** kwargs ) -> Dict : \" \"\" Update data for a previously processed document, including almost any field like `vendor`, `date`, `notes` and etc. ```veryfi_client.update_document(id, date=\" 2021 - 01 - 01 \", notes=\" look what I did \")``` :param document_id: ID of the document you'd like to update :param kwargs: fields to update :return: A document json with updated fields, if fields are writable. Otherwise a document with unchanged fields. \"\" \" endpoint_name = f \"/documents/{document_id}/\" return self . _request ( \"PUT\" , endpoint_name , kwargs )","title":"update_document"},{"location":"reference/veryfi/client/#update_line_item","text":"def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict Update an existing line item on an existing document. Parameters: Name Type Description Default document_id None ID of the document you'd like to update None line_item_id None ID of the line item you'd like to update None payload None line item object to update None Returns: Type Description None Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. View Source def update_line_item ( self , document_id : int , line_item_id : int , payload : Dict ) -> Dict : \"\"\" Update an existing line item on an existing document. :param document_id: ID of the document you'd like to update :param line_item_id: ID of the line item you'd like to update :param payload: line item object to update :return: Line item data with updated fields, if fields are writable. Otherwise line item data with unchanged fields. \"\"\" endpoint_name = f \"/documents/{document_id}/line-items/{line_item_id}\" request_arguments = UpdateLineItem ( ** payload ) . dict ( exclude_none = True ) return self . _request ( \"PUT\" , endpoint_name , request_arguments )","title":"update_line_item"},{"location":"reference/veryfi/errors/","text":"Module veryfi.errors None None View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) class UnauthorizedAccessToken ( VeryfiClientError ) : pass class BadRequest ( VeryfiClientError ) : pass class ResourceNotFound ( VeryfiClientError ) : pass class UnexpectedHTTPMethod ( VeryfiClientError ) : pass class AccessLimitReached ( VeryfiClientError ) : pass class InternalError ( VeryfiClientError ) : pass _error_map = { 400 : BadRequest , 404 : ResourceNotFound , 401 : UnauthorizedAccessToken , 405 : UnexpectedHTTPMethod , 409 : AccessLimitReached , 500 : InternalError , } Classes AccessLimitReached class AccessLimitReached ( raw_response , ** error_info ) View Source class AccessLimitReached ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. BadRequest class BadRequest ( raw_response , ** error_info ) View Source class BadRequest ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InternalError class InternalError ( raw_response , ** error_info ) View Source class InternalError ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ResourceNotFound class ResourceNotFound ( raw_response , ** error_info ) View Source class ResourceNotFound ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnauthorizedAccessToken class UnauthorizedAccessToken ( raw_response , ** error_info ) View Source class UnauthorizedAccessToken ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnexpectedHTTPMethod class UnexpectedHTTPMethod ( raw_response , ** error_info ) View Source class UnexpectedHTTPMethod ( VeryfiClientError ): pass Ancestors (in MRO) veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. VeryfiClientError class VeryfiClientError ( raw_response , ** error_info ) View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants veryfi.errors.UnauthorizedAccessToken veryfi.errors.BadRequest veryfi.errors.ResourceNotFound veryfi.errors.UnexpectedHTTPMethod veryfi.errors.AccessLimitReached veryfi.errors.InternalError Class variables args optional_fields Static methods from_response def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Errors"},{"location":"reference/veryfi/errors/#module-veryfierrors","text":"None None View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ()) class UnauthorizedAccessToken ( VeryfiClientError ) : pass class BadRequest ( VeryfiClientError ) : pass class ResourceNotFound ( VeryfiClientError ) : pass class UnexpectedHTTPMethod ( VeryfiClientError ) : pass class AccessLimitReached ( VeryfiClientError ) : pass class InternalError ( VeryfiClientError ) : pass _error_map = { 400 : BadRequest , 404 : ResourceNotFound , 401 : UnauthorizedAccessToken , 405 : UnexpectedHTTPMethod , 409 : AccessLimitReached , 500 : InternalError , }","title":"Module veryfi.errors"},{"location":"reference/veryfi/errors/#classes","text":"","title":"Classes"},{"location":"reference/veryfi/errors/#accesslimitreached","text":"class AccessLimitReached ( raw_response , ** error_info ) View Source class AccessLimitReached ( VeryfiClientError ): pass","title":"AccessLimitReached"},{"location":"reference/veryfi/errors/#ancestors-in-mro","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#badrequest","text":"class BadRequest ( raw_response , ** error_info ) View Source class BadRequest ( VeryfiClientError ): pass","title":"BadRequest"},{"location":"reference/veryfi/errors/#ancestors-in-mro_1","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_1","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_1","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_1","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#internalerror","text":"class InternalError ( raw_response , ** error_info ) View Source class InternalError ( VeryfiClientError ): pass","title":"InternalError"},{"location":"reference/veryfi/errors/#ancestors-in-mro_2","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_2","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_2","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_2","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#resourcenotfound","text":"class ResourceNotFound ( raw_response , ** error_info ) View Source class ResourceNotFound ( VeryfiClientError ): pass","title":"ResourceNotFound"},{"location":"reference/veryfi/errors/#ancestors-in-mro_3","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_3","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_3","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_3","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#unauthorizedaccesstoken","text":"class UnauthorizedAccessToken ( raw_response , ** error_info ) View Source class UnauthorizedAccessToken ( VeryfiClientError ): pass","title":"UnauthorizedAccessToken"},{"location":"reference/veryfi/errors/#ancestors-in-mro_4","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_4","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_4","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_4","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#unexpectedhttpmethod","text":"class UnexpectedHTTPMethod ( raw_response , ** error_info ) View Source class UnexpectedHTTPMethod ( VeryfiClientError ): pass","title":"UnexpectedHTTPMethod"},{"location":"reference/veryfi/errors/#ancestors-in-mro_5","text":"veryfi.errors.VeryfiClientError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#class-variables_5","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_5","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_5","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/errors/#veryficlienterror","text":"class VeryfiClientError ( raw_response , ** error_info ) View Source class VeryfiClientError ( Exception ) : optional_fields = [ \"error\", \"code\" ] def __init__ ( self , raw_response , ** error_info ) : for field_name in self . optional_fields : setattr ( self , field_name , error_info . get ( field_name )) self . raw_response = raw_response self . status = raw_response . status_code if getattr ( self , \"error\" ) : super (). __init__ ( f \"{self.status}, {getattr(self, 'error')}\" ) @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"VeryfiClientError"},{"location":"reference/veryfi/errors/#ancestors-in-mro_6","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/errors/#descendants","text":"veryfi.errors.UnauthorizedAccessToken veryfi.errors.BadRequest veryfi.errors.ResourceNotFound veryfi.errors.UnexpectedHTTPMethod veryfi.errors.AccessLimitReached veryfi.errors.InternalError","title":"Descendants"},{"location":"reference/veryfi/errors/#class-variables_6","text":"args optional_fields","title":"Class variables"},{"location":"reference/veryfi/errors/#static-methods_6","text":"","title":"Static methods"},{"location":"reference/veryfi/errors/#from_response_6","text":"def from_response ( raw_response ) Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } View Source @staticmethod def from_response ( raw_response ) : \"\"\"Veryfi API returns error messages with a json body like: { 'status': 'fail', 'error': 'Human readable error description.' } \"\"\" error_cls = _error_map . get ( raw_response . status_code ) or VeryfiClientError return error_cls ( raw_response , ** raw_response . json ())","title":"from_response"},{"location":"reference/veryfi/errors/#methods_6","text":"","title":"Methods"},{"location":"reference/veryfi/errors/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/veryfi/model/","text":"Module veryfi.model None None View Source from typing import Optional from pydantic import BaseModel class SharedLineItem ( BaseModel ): sku : Optional [ str ] category : Optional [ str ] tax : Optional [ float ] price : Optional [ float ] unit_of_measure : Optional [ str ] quantity : Optional [ float ] upc : Optional [ str ] tax_rate : Optional [ float ] discount_rate : Optional [ float ] start_date : Optional [ str ] end_date : Optional [ str ] hsn : Optional [ str ] section : Optional [ str ] weight : Optional [ str ] class AddLineItem ( SharedLineItem ): order : int description : str total : float class UpdateLineItem ( SharedLineItem ): order : Optional [ int ] description : Optional [ str ] total : Optional [ float ] Classes AddLineItem class AddLineItem ( __pydantic_self__ , ** data : Any ) View Source class AddLineItem ( SharedLineItem ): order: int description: str total: float Ancestors (in MRO) veryfi.model.SharedLineItem pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . SharedLineItem class SharedLineItem ( __pydantic_self__ , ** data : Any ) View Source class SharedLineItem ( BaseModel ) : sku : Optional [ str ] category : Optional [ str ] tax : Optional [ float ] price : Optional [ float ] unit_of_measure : Optional [ str ] quantity : Optional [ float ] upc : Optional [ str ] tax_rate : Optional [ float ] discount_rate : Optional [ float ] start_date : Optional [ str ] end_date : Optional [ str ] hsn : Optional [ str ] section : Optional [ str ] weight : Optional [ str ] Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Descendants veryfi.model.AddLineItem veryfi.model.UpdateLineItem Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . UpdateLineItem class UpdateLineItem ( __pydantic_self__ , ** data : Any ) View Source class UpdateLineItem ( SharedLineItem ) : order : Optional [ int ] description : Optional [ str ] total : Optional [ float ] Ancestors (in MRO) veryfi.model.SharedLineItem pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"Model"},{"location":"reference/veryfi/model/#module-veryfimodel","text":"None None View Source from typing import Optional from pydantic import BaseModel class SharedLineItem ( BaseModel ): sku : Optional [ str ] category : Optional [ str ] tax : Optional [ float ] price : Optional [ float ] unit_of_measure : Optional [ str ] quantity : Optional [ float ] upc : Optional [ str ] tax_rate : Optional [ float ] discount_rate : Optional [ float ] start_date : Optional [ str ] end_date : Optional [ str ] hsn : Optional [ str ] section : Optional [ str ] weight : Optional [ str ] class AddLineItem ( SharedLineItem ): order : int description : str total : float class UpdateLineItem ( SharedLineItem ): order : Optional [ int ] description : Optional [ str ] total : Optional [ float ]","title":"Module veryfi.model"},{"location":"reference/veryfi/model/#classes","text":"","title":"Classes"},{"location":"reference/veryfi/model/#addlineitem","text":"class AddLineItem ( __pydantic_self__ , ** data : Any ) View Source class AddLineItem ( SharedLineItem ): order: int description: str total: float","title":"AddLineItem"},{"location":"reference/veryfi/model/#ancestors-in-mro","text":"veryfi.model.SharedLineItem pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/model/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/veryfi/model/#static-methods","text":"","title":"Static methods"},{"location":"reference/veryfi/model/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"reference/veryfi/model/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/veryfi/model/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/veryfi/model/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/veryfi/model/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/veryfi/model/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/veryfi/model/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/veryfi/model/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/veryfi/model/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/veryfi/model/#methods","text":"","title":"Methods"},{"location":"reference/veryfi/model/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/veryfi/model/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/veryfi/model/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/veryfi/model/#sharedlineitem","text":"class SharedLineItem ( __pydantic_self__ , ** data : Any ) View Source class SharedLineItem ( BaseModel ) : sku : Optional [ str ] category : Optional [ str ] tax : Optional [ float ] price : Optional [ float ] unit_of_measure : Optional [ str ] quantity : Optional [ float ] upc : Optional [ str ] tax_rate : Optional [ float ] discount_rate : Optional [ float ] start_date : Optional [ str ] end_date : Optional [ str ] hsn : Optional [ str ] section : Optional [ str ] weight : Optional [ str ]","title":"SharedLineItem"},{"location":"reference/veryfi/model/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/model/#descendants","text":"veryfi.model.AddLineItem veryfi.model.UpdateLineItem","title":"Descendants"},{"location":"reference/veryfi/model/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/veryfi/model/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/veryfi/model/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"reference/veryfi/model/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/veryfi/model/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/veryfi/model/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/veryfi/model/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/veryfi/model/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/veryfi/model/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/veryfi/model/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/veryfi/model/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/veryfi/model/#methods_1","text":"","title":"Methods"},{"location":"reference/veryfi/model/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/veryfi/model/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/veryfi/model/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/veryfi/model/#updatelineitem","text":"class UpdateLineItem ( __pydantic_self__ , ** data : Any ) View Source class UpdateLineItem ( SharedLineItem ) : order : Optional [ int ] description : Optional [ str ] total : Optional [ float ]","title":"UpdateLineItem"},{"location":"reference/veryfi/model/#ancestors-in-mro_2","text":"veryfi.model.SharedLineItem pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/veryfi/model/#class-variables_2","text":"Config","title":"Class variables"},{"location":"reference/veryfi/model/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/veryfi/model/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"reference/veryfi/model/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/veryfi/model/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/veryfi/model/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/veryfi/model/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/veryfi/model/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/veryfi/model/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/veryfi/model/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/veryfi/model/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/veryfi/model/#methods_2","text":"","title":"Methods"},{"location":"reference/veryfi/model/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/veryfi/model/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/veryfi/model/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"}]}